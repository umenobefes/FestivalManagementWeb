name: Deploy to Azure Container Apps

on:
  push:
    branches:
      - release
  workflow_dispatch:

permissions:
  contents: read
  packages: write
  id-token: write

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Azure CLI
      run: |
        curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
        az version

    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Configure federated identity credentials for OIDC
      env:
        AZURE_CREDS: ${{ secrets.AZURE_CREDENTIALS }}
      run: |
        CLIENT_ID=$(echo "$AZURE_CREDS" | jq -r '.clientId')

        echo "Setting up federated credential for master branch..."
        az ad app federated-credential create \
          --id "$CLIENT_ID" \
          --parameters "{\"name\":\"github-actions-master\",\"issuer\":\"https://token.actions.githubusercontent.com\",\"subject\":\"repo:${{ github.repository }}:ref:refs/heads/master\",\"audiences\":[\"api://AzureADTokenExchange\"]}" \
          2>&1 | grep -v "already exists" || echo "Federated credential for master already exists or created"

        echo "Setting up federated credential for release branch..."
        az ad app federated-credential create \
          --id "$CLIENT_ID" \
          --parameters "{\"name\":\"github-actions-release\",\"issuer\":\"https://token.actions.githubusercontent.com\",\"subject\":\"repo:${{ github.repository }}:ref:refs/heads/release\",\"audiences\":[\"api://AzureADTokenExchange\"]}" \
          2>&1 | grep -v "already exists" || echo "Federated credential for release already exists or created"

        echo "‚úÖ Federated identity credentials configured"

    - name: Extract subscription ID from Azure credentials
      env:
        AZURE_CREDS: ${{ secrets.AZURE_CREDENTIALS }}
      run: |
        SUBSCRIPTION_ID=$(echo "$AZURE_CREDS" | jq -r '.subscriptionId')
        echo "SUBSCRIPTION_ID=$SUBSCRIPTION_ID" >> $GITHUB_ENV

    - name: Check GitHub Actions service principal permissions
      run: |
        echo "üîç Checking GitHub Actions service principal permissions..."

        CURRENT_USER=$(az account show --query user.name -o tsv)
        echo "   Current user: $CURRENT_USER"

        # Check role assignments
        echo ""
        echo "Checking role assignments on subscription..."
        ROLE_ASSIGNMENTS=$(az role assignment list --assignee "$CURRENT_USER" --scope "/subscriptions/$SUBSCRIPTION_ID" --query "[].{Role:roleDefinitionName}" -o json)

        echo "Assigned roles:"
        echo "$ROLE_ASSIGNMENTS" | jq -r '.[] | "   - \(.Role)"'

        # Check for required permissions
        HAS_CONTRIBUTOR=false
        HAS_USER_ACCESS_ADMIN=false
        HAS_OWNER=false

        if echo "$ROLE_ASSIGNMENTS" | jq -e '.[] | select(.Role == "Contributor")' > /dev/null 2>&1; then
          HAS_CONTRIBUTOR=true
        fi

        if echo "$ROLE_ASSIGNMENTS" | jq -e '.[] | select(.Role == "User Access Administrator")' > /dev/null 2>&1; then
          HAS_USER_ACCESS_ADMIN=true
        fi

        if echo "$ROLE_ASSIGNMENTS" | jq -e '.[] | select(.Role == "Owner")' > /dev/null 2>&1; then
          HAS_OWNER=true
        fi

        echo ""
        echo "üìã Permission check results:"

        if [ "$HAS_OWNER" = true ]; then
          echo "   ‚úÖ Owner role detected - all operations supported"
        elif [ "$HAS_CONTRIBUTOR" = true ] && [ "$HAS_USER_ACCESS_ADMIN" = true ]; then
          echo "   ‚úÖ Contributor + User Access Administrator - all operations supported"
        elif [ "$HAS_CONTRIBUTOR" = true ]; then
          echo "   ‚ö†Ô∏è  Contributor role only - can create resources but cannot assign roles"
          echo "   ‚ö†Ô∏è  FreeTier monitoring may not work without manual role assignment"
          echo ""
          echo "   To enable FreeTier monitoring, either:"
          echo "   1. Add 'User Access Administrator' role to the service principal, OR"
          echo "   2. Manually assign roles in Azure Portal after deployment:"
          echo "      - Monitoring Reader on Resource Group"
          echo "      - Cost Management Reader on Subscription"
        else
          echo "   ‚ùå Insufficient permissions detected"
          echo "   Required: Contributor + User Access Administrator (or Owner)"
        fi

        echo ""
        echo "Note: Deployment will continue, but some features may require manual configuration."

    - name: Extract parameters for resource group creation
      id: extract-params
      env:
        NAME_PREFIX_OVERRIDE: ${{ vars.NAME_PREFIX || '' }}
        LOCATION_OVERRIDE: ${{ vars.LOCATION || '' }}
      run: |
        # Use environment variable if set, otherwise read from parameters.json
        if [ -n "$NAME_PREFIX_OVERRIDE" ]; then
          NAME_PREFIX="$NAME_PREFIX_OVERRIDE"
          echo "Using NAME_PREFIX from environment variable: $NAME_PREFIX"
        else
          NAME_PREFIX=$(jq -r '.parameters.namePrefix.value' infra/parameters.json)
          echo "Using NAME_PREFIX from parameters.json: $NAME_PREFIX"
        fi

        if [ -n "$LOCATION_OVERRIDE" ]; then
          LOCATION="$LOCATION_OVERRIDE"
          echo "Using LOCATION from environment variable: $LOCATION"
        else
          LOCATION=$(jq -r '.parameters.location.value' infra/parameters.json)
          echo "Using LOCATION from parameters.json: $LOCATION"
        fi

        # Validate required parameters
        if [ -z "$NAME_PREFIX" ] || [ "$NAME_PREFIX" = "null" ]; then
          echo "Error: namePrefix is required in parameters.json"
          exit 1
        fi
        if [ -z "$LOCATION" ] || [ "$LOCATION" = "null" ]; then
          echo "Error: location is required in parameters.json"
          exit 1
        fi

        REGISTRY_REPOSITORY=$(jq -r '.parameters.containerRegistryRepository.value // empty' infra/parameters.json 2>/dev/null)
        REGISTRY_SERVER=$(jq -r '.parameters.containerRegistryServer.value // empty' infra/parameters.json 2>/dev/null)
        if [ "$REGISTRY_REPOSITORY" = "null" ]; then
          REGISTRY_REPOSITORY=""
        fi
        if [ -z "$REGISTRY_REPOSITORY" ]; then
          REGISTRY_REPOSITORY="${GITHUB_REPOSITORY}"
          REGISTRY_REPOSITORY=$(echo "$REGISTRY_REPOSITORY" | tr '[:upper:]' '[:lower:]')
        fi
        if [ "$REGISTRY_SERVER" = "null" ] || [ -z "$REGISTRY_SERVER" ]; then
          REGISTRY_SERVER="ghcr.io"
        fi

        IMAGE_NAME="${NAME_PREFIX}-app"
        echo "name-prefix=$NAME_PREFIX" >> $GITHUB_OUTPUT
        echo "location=$LOCATION" >> $GITHUB_OUTPUT
        echo "resource-group=rg-${NAME_PREFIX}" >> $GITHUB_OUTPUT
        echo "container-registry-repository=$REGISTRY_REPOSITORY" >> $GITHUB_OUTPUT
        echo "container-registry-server=$REGISTRY_SERVER" >> $GITHUB_OUTPUT
        echo "image-name=$IMAGE_NAME" >> $GITHUB_OUTPUT

    - name: Create Resource Group
      run: |
        az group create \
          --name ${{ steps.extract-params.outputs.resource-group }} \
          --location ${{ steps.extract-params.outputs.location }}

    - name: Create secrets JSON from app secrets
      env:
        APP_SECRETS_JSON: ${{ secrets.APP_SECRETS }}
      run: |
        if [ -z "$APP_SECRETS_JSON" ]; then
          echo "Error: APP_SECRETS secret is not set"
          exit 1
        fi
        echo "$APP_SECRETS_JSON" > infra/secrets.json

        # Validate JSON structure
        if ! jq -e '.googleClientId' infra/secrets.json > /dev/null; then
          echo "Error: APP_SECRETS must contain 'googleClientId'"
          exit 1
        fi
        if ! jq -e '.googleClientSecret' infra/secrets.json > /dev/null; then
          echo "Error: APP_SECRETS must contain 'googleClientSecret'"
          exit 1
        fi
        if ! jq -e '.initialUserEmail' infra/secrets.json > /dev/null; then
          echo "Error: APP_SECRETS must contain 'initialUserEmail'"
          exit 1
        fi
        if ! jq -e '.mongoAdminPassword' infra/secrets.json > /dev/null; then
          echo "Error: APP_SECRETS must contain 'mongoAdminPassword'"
          exit 1
        fi
        if ! jq -e '.gitSettings.authorName' infra/secrets.json > /dev/null; then
          echo "Error: APP_SECRETS must contain 'gitSettings.authorName'"
          exit 1
        fi
        if ! jq -e '.gitSettings.authorEmail' infra/secrets.json > /dev/null; then
          echo "Error: APP_SECRETS must contain 'gitSettings.authorEmail'"
          exit 1
        fi
        if ! jq -e '.gitSettings.token' infra/secrets.json > /dev/null; then
          echo "Error: APP_SECRETS must contain 'gitSettings.token'"
          exit 1
        fi
        if ! jq -e '.gitSettings.cloneUrl' infra/secrets.json > /dev/null; then
          echo "Error: APP_SECRETS must contain 'gitSettings.cloneUrl'"
          exit 1
        fi
        echo "All required secrets validated"

    - name: Extract secrets for Bicep parameters
      id: extract-secrets
      env:
        APP_SECRETS_JSON: ${{ secrets.APP_SECRETS }}
      run: |
        echo "google-client-id=$(echo "$APP_SECRETS_JSON" | jq -r '.googleClientId')" >> $GITHUB_OUTPUT
        echo "google-client-secret=$(echo "$APP_SECRETS_JSON" | jq -r '.googleClientSecret')" >> $GITHUB_OUTPUT
        echo "initial-user-email=$(echo "$APP_SECRETS_JSON" | jq -r '.initialUserEmail')" >> $GITHUB_OUTPUT
        echo "mongo-admin-password=$(echo "$APP_SECRETS_JSON" | jq -r '.mongoAdminPassword')" >> $GITHUB_OUTPUT
        echo "git-author-name=$(echo "$APP_SECRETS_JSON" | jq -r '.gitSettings.authorName')" >> $GITHUB_OUTPUT
        echo "git-author-email=$(echo "$APP_SECRETS_JSON" | jq -r '.gitSettings.authorEmail')" >> $GITHUB_OUTPUT
        echo "git-token=$(echo "$APP_SECRETS_JSON" | jq -r '.gitSettings.token')" >> $GITHUB_OUTPUT
        echo "git-clone-url=$(echo "$APP_SECRETS_JSON" | jq -r '.gitSettings.cloneUrl')" >> $GITHUB_OUTPUT

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Cache Docker layers
      uses: actions/cache@v3
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-

    - name: Build Docker image
      run: |
        docker build --no-cache -f FestivalManagementWeb/Dockerfile -t ${{ steps.extract-params.outputs.image-name }}:${{ github.sha }} .

    - name: Login to container registry
      run: |
        REGISTRY="${{ steps.extract-params.outputs.container-registry-server }}"
        if [ "$REGISTRY" = "ghcr.io" ]; then
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login "$REGISTRY" --username "${{ github.actor }}" --password-stdin
        else
          echo "Error: Only GHCR (ghcr.io) is supported as container registry"
          exit 1
        fi

    - name: Push Docker image
      run: |
        REPOSITORY="${{ steps.extract-params.outputs.container-registry-repository }}"
        REGISTRY="${{ steps.extract-params.outputs.container-registry-server }}"
        TARGET_IMAGE="$REGISTRY/$REPOSITORY"
        docker tag ${{ steps.extract-params.outputs.image-name }}:${{ github.sha }} $TARGET_IMAGE:${{ github.sha }}
        docker tag ${{ steps.extract-params.outputs.image-name }}:${{ github.sha }} $TARGET_IMAGE:latest
        docker push $TARGET_IMAGE:${{ github.sha }}
        docker push $TARGET_IMAGE:latest

    - name: Verify package visibility and make public
      run: |
        REPO_FULL="${{ steps.extract-params.outputs.container-registry-repository }}"
        OWNER=$(echo "$REPO_FULL" | cut -d'/' -f1)
        PACKAGE_NAME=$(echo "$REPO_FULL" | cut -d'/' -f2)

        echo "Checking package visibility for $OWNER/$PACKAGE_NAME..."

        # Check current visibility
        VISIBILITY=""

        # Try organization package first
        ORG_RESPONSE=$(curl -s -H "Accept: application/vnd.github+json" \
          -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          "https://api.github.com/orgs/$OWNER/packages/container/$PACKAGE_NAME" 2>/dev/null || echo "")

        if echo "$ORG_RESPONSE" | jq -e '.visibility' > /dev/null 2>&1; then
          VISIBILITY=$(echo "$ORG_RESPONSE" | jq -r '.visibility')
          echo "Package type: Organization"
        else
          # Try user package
          USER_RESPONSE=$(curl -s -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/users/$OWNER/packages/container/$PACKAGE_NAME" 2>/dev/null || echo "")

          if echo "$USER_RESPONSE" | jq -e '.visibility' > /dev/null 2>&1; then
            VISIBILITY=$(echo "$USER_RESPONSE" | jq -r '.visibility')
            echo "Package type: User"
          fi
        fi

        echo "Current visibility: $VISIBILITY"

        # If already public, we're done
        if [ "$VISIBILITY" = "public" ]; then
          echo "‚úÖ Package is already public - deployment can proceed"
          exit 0
        fi

        # If private and no GH_PAT, abort
        if [ "$VISIBILITY" = "private" ] && [ -z "${{ secrets.GH_PAT }}" ]; then
          echo ""
          echo "‚ùå ERROR: Package is PRIVATE but cannot be made public"
          echo ""
          echo "Container Apps cannot pull private packages from GHCR."
          echo "You must either:"
          echo ""
          echo "1. Create a GitHub Personal Access Token with 'write:packages' scope:"
          echo "   https://github.com/settings/tokens/new?scopes=write:packages,read:packages"
          echo ""
          echo "2. Add it as a repository secret named 'GH_PAT':"
          echo "   gh secret set GH_PAT"
          echo ""
          echo "3. Re-run this workflow"
          echo ""
          echo "The workflow will then automatically make the package public."
          exit 1
        fi

        # Try to make it public
        if [ -n "${{ secrets.GH_PAT }}" ]; then
          echo "Attempting to make package public using GH_PAT..."

          # Try organization first
          if curl -s -X PATCH \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GH_PAT }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/orgs/$OWNER/packages/container/$PACKAGE_NAME" \
            -d '{"visibility":"public"}' 2>&1 | grep -q '"visibility":"public"'; then
            echo "‚úÖ Package set to public (organization)"
            exit 0
          fi

          # Try user package
          if curl -s -X PATCH \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GH_PAT }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/users/$OWNER/packages/container/$PACKAGE_NAME" \
            -d '{"visibility":"public"}' 2>&1 | grep -q '"visibility":"public"'; then
            echo "‚úÖ Package set to public (user)"
            exit 0
          fi

          echo "‚ùå Failed to make package public even with GH_PAT"
          echo "Please manually set the package to public in GitHub:"
          echo "https://github.com/$OWNER?tab=packages"
          exit 1
        fi

        # Unknown visibility
        echo "‚ö†Ô∏è  Could not determine package visibility"
        echo "Proceeding with deployment - if the package is private, deployment will fail"

    - name: Deploy infrastructure only (Cosmos DB + Environment)
      id: deploy-infrastructure
      env:
        NAME_PREFIX: ${{ steps.extract-params.outputs.name-prefix }}
        RESOURCE_GROUP: ${{ steps.extract-params.outputs.resource-group }}
        LOCATION: ${{ steps.extract-params.outputs.location }}
        MONGO_ADMIN_PASSWORD: ${{ steps.extract-secrets.outputs.mongo-admin-password }}
      run: |
        set -euo pipefail

        ENV_NAME="${NAME_PREFIX}-env"
        COSMOS_NAME="${NAME_PREFIX}-cosmos"

        # Check if infrastructure already exists
        ENV_EXISTS=false
        COSMOS_EXISTS=false

        if az containerapp env show --name "$ENV_NAME" --resource-group "$RESOURCE_GROUP" &>/dev/null; then
          echo "‚úÖ Container Apps Environment already exists: $ENV_NAME"
          ENV_EXISTS=true
        fi

        if az cosmosdb mongocluster show --cluster-name "$COSMOS_NAME" --resource-group "$RESOURCE_GROUP" &>/dev/null 2>&1; then
          echo "‚úÖ Cosmos DB already exists: $COSMOS_NAME"
          COSMOS_EXISTS=true
        fi

        # Determine what to create
        CREATE_NEW_ENVIRONMENT=false
        CREATE_NEW_COSMOS=false

        if [ "$ENV_EXISTS" = false ]; then
          CREATE_NEW_ENVIRONMENT=true
          echo "Will create new Container Apps Environment"
        fi

        if [ "$COSMOS_EXISTS" = false ]; then
          CREATE_NEW_COSMOS=true
          echo "Will create new Cosmos DB"
        fi

        # Deploy infrastructure
        echo "Deploying infrastructure..."
        az deployment group create \
          --name "infra-${{ github.run_number }}-${{ github.run_attempt }}" \
          --resource-group "$RESOURCE_GROUP" \
          --template-file infra/infrastructure.bicep \
          --parameters namePrefix="$NAME_PREFIX" \
          --parameters location="$LOCATION" \
          --parameters mongoAdminPassword="$MONGO_ADMIN_PASSWORD" \
          --parameters createNewEnvironment=$CREATE_NEW_ENVIRONMENT \
          --parameters createNewCosmosDb=$CREATE_NEW_COSMOS \
          --output json > infra-output.json

        ENV_ID=$(jq -r '.properties.outputs.environmentId.value' infra-output.json)

        echo "environmentId=$ENV_ID" >> $GITHUB_OUTPUT
        echo "cosmosDbAccountName=$COSMOS_NAME" >> $GITHUB_OUTPUT
        echo "‚úÖ Infrastructure deployment completed"

    - name: Deploy Container App
      id: deploy-app
      env:
        NAME_PREFIX: ${{ steps.extract-params.outputs.name-prefix }}
        RESOURCE_GROUP: ${{ steps.extract-params.outputs.resource-group }}
        LOCATION: ${{ steps.extract-params.outputs.location }}
        ENVIRONMENT_ID: ${{ steps.deploy-infrastructure.outputs.environmentId }}
        COSMOS_NAME: ${{ steps.deploy-infrastructure.outputs.cosmosDbAccountName }}
        CONTAINER_REGISTRY_SERVER: ${{ steps.extract-params.outputs.container-registry-server }}
        CONTAINER_REGISTRY_REPOSITORY: ${{ steps.extract-params.outputs.container-registry-repository }}
        REGISTRY_USERNAME: ${{ github.actor }}
        REGISTRY_PASSWORD: ${{ secrets.GITHUB_TOKEN }}
        MONGO_ADMIN_PASSWORD: ${{ steps.extract-secrets.outputs.mongo-admin-password }}
        GOOGLE_CLIENT_ID: ${{ steps.extract-secrets.outputs.google-client-id }}
        GOOGLE_CLIENT_SECRET: ${{ steps.extract-secrets.outputs.google-client-secret }}
        INITIAL_USER_EMAIL: ${{ steps.extract-secrets.outputs.initial-user-email }}
        GIT_AUTHOR_NAME: ${{ steps.extract-secrets.outputs.git-author-name }}
        GIT_AUTHOR_EMAIL: ${{ steps.extract-secrets.outputs.git-author-email }}
        GIT_TOKEN: ${{ steps.extract-secrets.outputs.git-token }}
        GIT_CLONE_URL: ${{ steps.extract-secrets.outputs.git-clone-url }}
      run: |
        set -euo pipefail

        APP_NAME="${NAME_PREFIX}-app"
        IMAGE_TAG="latest"
        IMAGE_REF="${CONTAINER_REGISTRY_SERVER}/${CONTAINER_REGISTRY_REPOSITORY}:${IMAGE_TAG}"
        REGISTRY_USERNAME_LOWER=$(echo "$REGISTRY_USERNAME" | tr '[:upper:]' '[:lower:]')

        # Check if app exists
        APP_EXISTS=false
        if az containerapp show --name "$APP_NAME" --resource-group "$RESOURCE_GROUP" &>/dev/null; then
          APP_EXISTS=true
          echo "Container App already exists, will update it"
        fi

        # Prepare MongoDB connection string
        ENCODED_PASSWORD=$(printf %s "$MONGO_ADMIN_PASSWORD" | jq -sRr @uri)
        MONGO_CONN="mongodb+srv://mongoAdmin:${ENCODED_PASSWORD}@${COSMOS_NAME}.mongocluster.cosmos.azure.com/?tls=true&authMechanism=SCRAM-SHA-256&retrywrites=false&maxIdleTimeMS=120000"

        if [ "$APP_EXISTS" = false ]; then
          echo "Creating Container App with az containerapp create..."
          az containerapp create \
            --name "$APP_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --environment "$ENVIRONMENT_ID" \
            --image "$IMAGE_REF" \
            --target-port 8080 \
            --ingress external \
            --registry-server "$CONTAINER_REGISTRY_SERVER" \
            --registry-username "$REGISTRY_USERNAME_LOWER" \
            --registry-password "$REGISTRY_PASSWORD" \
            --cpu 0.5 \
            --memory 1.0Gi \
            --min-replicas 0 \
            --max-replicas 1 \
            --system-assigned \
            --secrets \
              mongo-connection-string="$MONGO_CONN" \
              google-client-id="$GOOGLE_CLIENT_ID" \
              google-client-secret="$GOOGLE_CLIENT_SECRET" \
              initial-user-email="$INITIAL_USER_EMAIL" \
              git-token="$GIT_TOKEN" \
              git-clone-url="$GIT_CLONE_URL" \
            --env-vars \
              ASPNETCORE_ENVIRONMENT=Production \
              MongoDbSettings__ConnectionString=secretref:mongo-connection-string \
              MongoDbSettings__DatabaseName=FestivalManagement \
              Authentication__Google__ClientId=secretref:google-client-id \
              Authentication__Google__ClientSecret=secretref:google-client-secret \
              InitialUser__Email=secretref:initial-user-email \
              GitSettings__RemoteName=origin \
              GitSettings__AuthorName="$GIT_AUTHOR_NAME" \
              GitSettings__AuthorEmail="$GIT_AUTHOR_EMAIL" \
              GitSettings__Token=secretref:git-token \
              GitSettings__CloneUrl=secretref:git-clone-url
        else
          echo "Updating existing Container App..."
          az containerapp update \
            --name "$APP_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --image "$IMAGE_REF" \
            --cpu 0.5 \
            --memory 1.0Gi
        fi

        # Add FreeTier and AzureUsage environment variables
        echo "Adding FreeTier configuration..."
        SUBSCRIPTION_ID=$(az account show --query id -o tsv)

        az containerapp update \
          --name "$APP_NAME" \
          --resource-group "$RESOURCE_GROUP" \
          --set-env-vars \
            FreeTier__EnableBanner=true \
            FreeTier__BudgetVcpuSeconds=180000 \
            FreeTier__BudgetGiBSeconds=360000 \
            FreeTier__Resource__VcpuPerReplica=0.5 \
            FreeTier__Resource__MemoryGiBPerReplica=1.0 \
            FreeTier__Resource__ReplicaFactor=1 \
            FreeTier__EnforceRequestDailyCap=false \
            FreeTier__Data__BudgetGb=100 \
            FreeTier__Requests__Budget=2000000 \
            FreeTier__Cosmos__Enabled=true \
            FreeTier__Cosmos__SubscriptionId=$SUBSCRIPTION_ID \
            FreeTier__Cosmos__ResourceGroup=$RESOURCE_GROUP \
            FreeTier__Cosmos__AccountName=$COSMOS_NAME \
            FreeTier__Cosmos__DatabaseName=FestivalManagement \
            FreeTier__Cosmos__AccountResourceId=/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.DocumentDB/mongoClusters/$COSMOS_NAME \
            FreeTier__Cosmos__Provisioning=vCore \
            FreeTier__Cosmos__FreeTierStorageGb=32 \
            FreeTier__Cosmos__FreeTierVCoreStorageGb=32 \
            FreeTier__Cosmos__WarnRuPercent=90 \
            FreeTier__Cosmos__WarnStoragePercent=90 \
            FreeTier__Cosmos__RefreshMinutes=60 \
            FreeTier__Cosmos__CollectionNames__0=TextKeyValues \
            FreeTier__Cosmos__CollectionNames__1=ImageKeyValues \
            AzureUsage__Enabled=true \
            AzureUsage__ContainerAppName=$APP_NAME \
            AzureUsage__ResourceGroup=$RESOURCE_GROUP \
            AzureUsage__SubscriptionId=$SUBSCRIPTION_ID \
            AzureUsage__MetricsRefreshMinutes=10 \
            AzureUsage__CostRefreshMinutes=360

        # Get outputs
        APP_URL=$(az containerapp show --name "$APP_NAME" --resource-group "$RESOURCE_GROUP" --query "properties.configuration.ingress.fqdn" -o tsv)
        PRINCIPAL_ID=$(az containerapp show --name "$APP_NAME" --resource-group "$RESOURCE_GROUP" --query "identity.principalId" -o tsv)

        echo "containerAppUrl=https://$APP_URL" >> $GITHUB_OUTPUT
        echo "containerAppPrincipalId=$PRINCIPAL_ID" >> $GITHUB_OUTPUT
        echo "containerAppName=$APP_NAME" >> $GITHUB_OUTPUT

        echo "‚úÖ Container App deployment completed"
        echo "   Application URL: https://$APP_URL"

    - name: Configure scale settings (300 second cooldown)
      env:
        APP_NAME: ${{ steps.deploy-app.outputs.containerAppName }}
        RESOURCE_GROUP: ${{ steps.extract-params.outputs.resource-group }}
      run: |
        echo "Attempting to configure scale-to-zero with 300 second cooldown..."

        # Try to update scale rule with cooldown period
        SCALE_LOG=$(mktemp)

        # Method 1: Try updating with --scale-rule-metadata
        echo "Method 1: Updating scale rule metadata..."
        if az containerapp update \
          --name "$APP_NAME" \
          --resource-group "$RESOURCE_GROUP" \
          --scale-rule-name http-rule \
          --scale-rule-type http \
          --scale-rule-http-concurrency 30 \
          --scale-rule-metadata cooldownPeriod=300 pollingInterval=30 \
          --min-replicas 0 \
          --max-replicas 1 \
          > "$SCALE_LOG" 2>&1; then
          echo "‚úÖ Scale rule updated with cooldown metadata"
          cat "$SCALE_LOG"
        else
          echo "‚ö†Ô∏è  Method 1 failed, trying alternative..."
          cat "$SCALE_LOG"

          # Method 2: Try az rest API directly
          echo "Method 2: Using Azure REST API..."
          APP_ID=$(az containerapp show --name "$APP_NAME" --resource-group "$RESOURCE_GROUP" --query id -o tsv)

          if az rest \
            --method patch \
            --uri "${APP_ID}?api-version=2024-03-01" \
            --body '{
              "properties": {
                "template": {
                  "scale": {
                    "minReplicas": 0,
                    "maxReplicas": 1,
                    "rules": [
                      {
                        "name": "http-rule",
                        "http": {
                          "metadata": {
                            "concurrentRequests": "30"
                          }
                        }
                      }
                    ],
                    "cooldownPeriod": 300,
                    "pollingInterval": 30
                  }
                }
              }
            }' \
            > "$SCALE_LOG" 2>&1; then
            echo "‚úÖ Scale settings updated via REST API"
            cat "$SCALE_LOG"
          else
            echo "‚ö†Ô∏è  Method 2 also failed"
            cat "$SCALE_LOG"
            echo "‚ÑπÔ∏è  Falling back to default behavior (~2-5 minutes)"
          fi
        fi

        rm -f "$SCALE_LOG"

        # Show current scale configuration
        echo ""
        echo "Current scale configuration:"
        az containerapp show \
          --name "$APP_NAME" \
          --resource-group "$RESOURCE_GROUP" \
          --query "properties.template.scale" \
          -o json || true

    - name: Assign Azure roles to Container App Managed Identity
      if: steps.deploy-app.outputs.containerAppPrincipalId != '' && steps.deploy-app.outputs.containerAppPrincipalId != 'null'
      env:
        PRINCIPAL_ID: ${{ steps.deploy-app.outputs.containerAppPrincipalId }}
        RESOURCE_GROUP: ${{ steps.extract-params.outputs.resource-group }}
        COSMOS_NAME: ${{ steps.deploy-infrastructure.outputs.cosmosDbAccountName }}
      run: |
        echo "üîê Assigning Azure roles for FreeTier monitoring..."
        echo "   Principal ID: $PRINCIPAL_ID"

        # Get subscription ID
        SUBSCRIPTION_ID=$(az account show --query id -o tsv)

        # Function to assign role with retry
        assign_role_with_retry() {
          local role_name="$1"
          local scope_type="$2"
          local scope_value="$3"
          local max_attempts=3

          for attempt in $(seq 1 $max_attempts); do
            echo ""
            echo "Assigning $role_name (attempt $attempt/$max_attempts)..."

            ASSIGN_LOG=$(mktemp)
            ASSIGN_RESULT=false

            if [ "$scope_type" = "resource-group" ]; then
              if az role assignment create \
                --assignee-object-id "$PRINCIPAL_ID" \
                --assignee-principal-type ServicePrincipal \
                --role "$role_name" \
                --resource-group "$scope_value" \
                > "$ASSIGN_LOG" 2>&1; then
                ASSIGN_RESULT=true
              fi
            elif [ "$scope_type" = "subscription" ]; then
              if az role assignment create \
                --assignee-object-id "$PRINCIPAL_ID" \
                --assignee-principal-type ServicePrincipal \
                --role "$role_name" \
                --scope "/subscriptions/$scope_value" \
                > "$ASSIGN_LOG" 2>&1; then
                ASSIGN_RESULT=true
              fi
            elif [ "$scope_type" = "resource" ]; then
              if az role assignment create \
                --assignee-object-id "$PRINCIPAL_ID" \
                --assignee-principal-type ServicePrincipal \
                --role "$role_name" \
                --scope "$scope_value" \
                > "$ASSIGN_LOG" 2>&1; then
                ASSIGN_RESULT=true
              fi
            fi

            if [ "$ASSIGN_RESULT" = true ]; then
              echo "‚úÖ Successfully assigned $role_name"
              rm -f "$ASSIGN_LOG"
              return 0
            elif grep -qi "already exists\|already assigned" "$ASSIGN_LOG"; then
              echo "‚ÑπÔ∏è  $role_name already assigned"
              rm -f "$ASSIGN_LOG"
              return 0
            else
              echo "‚ö†Ô∏è  Attempt $attempt failed:"
              cat "$ASSIGN_LOG"
              rm -f "$ASSIGN_LOG"

              if [ $attempt -lt $max_attempts ]; then
                echo "Waiting 10 seconds before retry..."
                sleep 10
              fi
            fi
          done

          echo "‚ùå Failed to assign $role_name after $max_attempts attempts"
          return 1
        }

        # Wait for Managed Identity to propagate
        echo "Waiting 30 seconds for Managed Identity to propagate in Azure AD..."
        sleep 30

        # 1. Reader role on Resource Group (for general resource access)
        assign_role_with_retry "Reader" "resource-group" "$RESOURCE_GROUP" || {
          echo "::warning::Failed to assign Reader role - monitoring features may not work"
        }

        # 2. Monitoring Reader role on Resource Group (for metrics access)
        assign_role_with_retry "Monitoring Reader" "resource-group" "$RESOURCE_GROUP" || {
          echo "::error::Failed to assign Monitoring Reader role - this is REQUIRED for FreeTier monitoring"
          exit 1
        }

        # 3. Cost Management Reader role on Subscription (for cost data)
        assign_role_with_retry "Cost Management Reader" "subscription" "$SUBSCRIPTION_ID" || {
          echo "::warning::Failed to assign Cost Management Reader role - cost monitoring may not work"
          echo "::warning::You may need to manually assign this role in Azure Portal"
          echo "::warning::Required permission: User Access Administrator or Owner at subscription level"
        }

        # 4. Monitoring Reader on Cosmos DB (for Cosmos metrics)
        COSMOS_ID=$(az cosmosdb mongocluster show --cluster-name "$COSMOS_NAME" --resource-group "$RESOURCE_GROUP" --query id -o tsv 2>/dev/null || echo "")
        if [ -n "$COSMOS_ID" ] && [ "$COSMOS_ID" != "null" ]; then
          assign_role_with_retry "Monitoring Reader" "resource" "$COSMOS_ID" || {
            echo "::warning::Failed to assign Monitoring Reader role on Cosmos DB"
          }
        else
          echo "‚ö†Ô∏è  Could not find Cosmos DB resource ID, skipping Cosmos-specific role assignment"
        fi

        echo ""
        echo "‚úÖ Role assignment completed"
        echo ""
        echo "üìä Summary of permissions for FreeTier monitoring:"
        echo "   ‚úì Reader on Resource Group          ‚Üí General resource access"
        echo "   ‚úì Monitoring Reader on RG           ‚Üí Container Apps metrics (CPU, Memory, Requests)"
        echo "   ‚úì Cost Management Reader on Sub     ‚Üí Cost data (if assigned)"
        echo "   ‚úì Monitoring Reader on Cosmos DB    ‚Üí Database metrics (if assigned)"
        echo ""
        echo "If any warnings appeared above, the app may not be able to display all monitoring data."
        echo "To fix: Grant 'User Access Administrator' role to the GitHub Actions service principal."

    - name: Cleanup secrets
      if: always()
      run: rm -f infra/secrets.json

    - name: Output application URL
      run: |
        echo "Application deployed to: ${{ steps.deploy-app.outputs.containerAppUrl }}"
